"""
Parameter classes for model configuration
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional, Union

import pydash
from pydantic import BaseModel, TypeAdapter

from .base import BaseModelClass
from .constants import (
    ParameterActionTypeEnum,
    ParameterCheckTypeEnum,
    ParameterDisplayTypeEnum,
    ParameterTagEnum,
    ParameterTypeEnum,
)
from .model_info import ModelList
from .utils import checkPath, open_ex, printError, printProcess, printWarning


class ParameterCheck(BaseModel):
    type: Optional[ParameterCheckTypeEnum] = None
    path: Optional[str] = None

    def check(self, oliveJson: Any):
        if not self.type:
            return False
        if not self.path:
            return False
        if not checkPath(self.path, oliveJson):
            return False
        return True


class ParameterAction(BaseModel):
    type: Optional[ParameterActionTypeEnum] = None
    path: Optional[str] = None
    value: Optional[Union[str, int, bool, float, Any]] = None

    def check(self, oliveJson: Any):
        if not self.type:
            return False
        if not self.path:
            return False
        if self.type in [ParameterActionTypeEnum.Insert, ParameterActionTypeEnum.Update] and not self.value:
            return False
        pathExist = checkPath(self.path, oliveJson, False)
        if self.type in [ParameterActionTypeEnum.Delete, ParameterActionTypeEnum.Update] and not pathExist:
            return False
        if self.type in [ParameterActionTypeEnum.Insert] and pathExist:
            return False
        return True


class Parameter(BaseModel):
    """
    REMEMEBER to update clearValue and applyTemplate if new fields are added
    for enum type and bool type, either path + values or checks + actions

    path: path to the parameter in olive json
    values: possible values for the parameter.
        path and values are used to determine the status of the parameter
    checks: advanced method to get default value for enum or bool
    actions: actions to be performed on the parameter in template(original) olive json.
        if actions is empty, the parameter is upserted by path = selected value

    """

    # This tag is only used for the case that when we edit the json, we know the property is auto generated by sanitize.py so no need to care about it
    autoGenerated: Optional[bool] = None
    name: Optional[str] = None
    tags: Optional[List[ParameterTagEnum]] = None
    description: Optional[str] = None
    descriptionLink: Optional[str] = None
    type: Optional[ParameterTypeEnum] = None
    displayNames: Optional[List[str]] = None
    displayType: Optional[ParameterDisplayTypeEnum] = None
    path: Optional[str] = None
    values: Optional[List[Any]] = None
    # TODO update to expression
    selectors: Optional[List[ParameterCheck]] = None
    actions: Optional[List[List[ParameterAction]]] = None
    readOnly: Optional[bool] = None
    customize: Optional[bool] = None
    # When the path does not exist, we will use this value as the default value
    # defaultValue is already used in Skylight, so do not use it
    fallbackValue: Optional[Any] = None
    # Template can be:
    # 1. A Parameter object (with its own template field as str)
    # 2. A string (template name)
    # When template is a Parameter object, template.template should be str
    # always put template in the end
    template: Optional[Union[Parameter, str]] = None

    def Check(
        self,
        isTemplate: bool,
        oliveJson: Any = None,
        modelList: Optional[ModelList] = None,
    ):
        if isTemplate:
            if self.template:
                return False
            return True

        if not self.name:
            return False
        if not self.description:
            if self.descriptionLink:
                printError("Description link should not be used without description")
                return False
        if not self.type:
            return False
        if self.type != ParameterTypeEnum.Bool and self.type != ParameterTypeEnum.Enum:
            if not self.path:
                return False
            elif not checkPath(self.path, oliveJson):
                return False
            elif self.values or self.selectors or self.actions or self.displayNames or self.customize:
                printError("Redundant fields")
                return False
        else:
            expectedLength = 2
            lenValues = len(self.values) if self.values else 0
            lenChecks = len(self.selectors) if self.selectors else 0
            lenActions = len(self.actions) if self.actions else 0
            if self.type == ParameterTypeEnum.Enum:
                expectedLength = max(lenValues, lenChecks)
                if expectedLength == 0:
                    printError("Enum should have values or checks")
                    return False

            # Display names
            if self.type == ParameterTypeEnum.Enum and self.selectors and not self.displayNames:
                printError("Display names should be used with checks")
                return False

            if self.displayNames and len(self.displayNames) != expectedLength:
                printError(f"Display names has wrong length {expectedLength}")
                return False

            # Display type
            if self.type == ParameterTypeEnum.Enum:
                if not (
                    not self.displayType
                    or self.displayType == ParameterDisplayTypeEnum.Dropdown
                    or self.displayType == ParameterDisplayTypeEnum.RadioGroup
                ):
                    printError("Display type should be Dropdown or RadioGroup")
                    return False

            # customize
            if self.customize == True:
                if not (self.type == ParameterTypeEnum.Enum and self.values and not self.selectors):
                    printError("Wrong customize prerequisites!")
                    return False

            # path: bool
            # path + actions: bool
            # path + values: enum
            # path + values + actions: bool, enum
            # checks + actions: bool, enum
            if (
                self.type == ParameterTypeEnum.Bool
                and self.path
                and not self.values
                and not self.selectors
                and not self.actions
            ):
                pass
            elif (
                self.type == ParameterTypeEnum.Bool
                and self.path
                and not self.values
                and not self.selectors
                and lenActions == expectedLength
            ):
                pass
            elif (
                self.type == ParameterTypeEnum.Enum
                and self.path
                and lenValues == expectedLength
                and not self.selectors
                and not self.actions
            ):
                pass
            elif self.path and lenValues == expectedLength and not self.selectors and lenActions == expectedLength:
                pass
            elif not self.path and not self.values and lenChecks == expectedLength and lenActions == expectedLength:
                pass
            else:
                printError(f"Invalid combination. Check comment")
                return False
            if self.path:
                if not checkPath(self.path, oliveJson):
                    return False
                # TODO more checks
                if self.values:
                    value = pydash.get(oliveJson, self.path)
                    if self.tags and (
                        ParameterTagEnum.EvaluationDataset in self.tags
                        or ParameterTagEnum.QuantizationDataset in self.tags
                    ):
                        if value != self.values[0]:
                            printError(f"Value {value} not the first in values for {self.path}")
                            return False
                        for i in range(len(self.values) - 1):
                            value_in_list = self.values[i + 1]
                            if modelList and value_in_list not in modelList.DatasetSplit:
                                printError(f"Value {value_in_list} not in DatasetSplit for {self.path}")
                                return False
                            if modelList and value_in_list not in modelList.DatasetSubset:
                                # No error for this, just warning
                                printWarning(
                                    f"Value {value_in_list} not in DatasetSubset for {self.path}. Could be acceptable if it doesn't have subset"
                                )
                    elif value and value not in self.values:
                        printError(f"Value {value} not in values for {self.path}")
                        return False

            if self.selectors:
                for i, check in enumerate(self.selectors):
                    if not check.check(oliveJson):
                        printError(f"Check {i} has error")
                        return False

            if self.actions:
                for i, actions in enumerate(self.actions):
                    for j, action in enumerate(actions):
                        if not action.check(oliveJson):
                            printError(f"Action {i} {j} has error")
                            return False
        return True

    def clearValue(self):
        """
        Clear everything except template
        """
        for attr in vars(self):
            if attr != "template":
                setattr(self, attr, None)

    def applyTemplate(self, template: Parameter):
        """
        Apply everything except template
        """
        for attr, value in vars(template).items():
            if not getattr(self, attr) and attr != "template":
                setattr(self, attr, value)


def readCheckParameterTemplate(filePath: str):
    printProcess(filePath)
    with open_ex(filePath, "r") as file:
        fileContent = file.read()
    adapter = TypeAdapter(Dict[str, Parameter])
    parameters: Dict[str, Parameter] = adapter.validate_json(fileContent, strict=True)
    for key, parameter in parameters.items():
        if not parameter.Check(True):
            printError(f"{filePath} parameter {key} has error")
    newContent = adapter.dump_json(parameters, indent=4, exclude_none=True).decode("utf-8")
    BaseModelClass.writeJsonIfChanged(newContent, filePath, fileContent)
    return parameters
