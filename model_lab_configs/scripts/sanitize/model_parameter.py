"""
Model parameter configuration classes
"""
from __future__ import annotations
from typing import Any, Dict, List, Optional
from pydantic import BaseModel

from scripts.model_lab import RuntimeEnum, RuntimeEnum, RuntimeFeatureEnum
from scripts.sanitize.model_info import ModelList

from .base import BaseModelClass
from .constants import EPNames, PhaseTypeEnum, OlivePropertyNames, OlivePassNames
from .parameters import Parameter, ParameterAction
from .constants import ParameterTypeEnum, ParameterActionTypeEnum, ParameterTagEnum
from .utils import open_ex, printProcess, printError, printWarning, checkPath, GlobalVars
import json
import re
import pydash
from deepdiff import DeepDiff
import os


class RuntimeOverwrite(BaseModel):
    # This tag is only used for the case that when we edit the json, we know the property is auto generated by sanitize.py so no need to care about it 
    autoGenerated: Optional[bool] = None
    pyEnvPath: Optional[str] = None
    executeEp: Optional[EPNames] = None
    # This is usually used for EP binary generation
    evaluateUsedInExecute: Optional[bool] = None

    def Check(self, oliveJson: Any):
        return self.pyEnvPath and checkPath(self.pyEnvPath, oliveJson)

class Section(BaseModel):
    # This tag is only used for the case that when we edit the json, we know the property is auto generated by sanitize.py so no need to care about it 
    autoGenerated: Optional[bool] = None
    name: str
    phase: PhaseTypeEnum
    description: Optional[str] = None
    parameters: List[Parameter]
    toggle: Optional[Parameter] = None

    @staticmethod
    def datasetPathPattern(path: str): 
        return re.fullmatch(r'data_configs\[(0|[1-9]\d{0,2})\]\.load_dataset_config\.data_name', path)

    def Check(self, templates: Dict[str, Parameter], _file: str, sectionId: int, oliveJson: Any, modelList: ModelList):
        if not self.name:
            return False
        #if not self.description:
        #    return False
        # TODO add place holder for General?
        if not self.parameters and self.phase != PhaseTypeEnum.Conversion:
            printWarning(f"self.parameters is empty for {self.phase}.")
        
        for i, parameter in enumerate(self.parameters):
            if parameter.template:
                template = parameter.template
                if not isinstance(template, Parameter):
                    printError(f"{_file} section {sectionId} parameter {i} has wrong template")
                    continue
                if template.template not in templates:
                    printError(f"{_file} section {sectionId} parameter {i} has wrong template")
                    continue
                parameter.clearValue()
                parameter.applyTemplate(template)
                parameter.applyTemplate(templates[str(template.template)])
            if not parameter.Check(False, oliveJson, modelList):
                printError(f"{_file} section {sectionId} parameter {i} has error")

            # TODO move tag check into Parameter
            if Section.datasetPathPattern(parameter.path):
                if self.phase == PhaseTypeEnum.Quantization:
                    if not parameter.tags or ParameterTagEnum.QuantizationDataset not in parameter.tags:
                        printError(f"{_file} section {sectionId} parameter {i} should have QuantizationDataset tag")
                elif self.phase == PhaseTypeEnum.Evaluation:
                    if not parameter.tags or ParameterTagEnum.EvaluationDataset not in parameter.tags:
                        printError(f"{_file} section {sectionId} parameter {i} should have EvaluationDataset tag")
                missing_keys = [key for key in parameter.values if key not in modelList.HFDatasets]
                if missing_keys:
                    printError(f"datasets are not in HFDatasets: {', '.join(missing_keys)}")
            elif parameter.path.endswith("activation_type"):
                if not parameter.tags or ParameterTagEnum.ActivationType not in parameter.tags:
                    printError(f"{_file} section {sectionId} parameter {i} should have ActivationType tag")
            elif parameter.path.endswith("weight_type"):
                if not parameter.tags or ParameterTagEnum.WeightType not in parameter.tags:
                    printError(f"{_file} section {sectionId} parameter {i} should have WeightType tag")

        if self.toggle:
            if self.toggle.type != ParameterTypeEnum.Bool:
                printError(f"{_file} section {sectionId} toggle must use bool")
                return False
            if not self.toggle.Check(False, oliveJson, modelList):
                printError(f"{_file} section {sectionId} toggle has error")

        return True


class ADMNPUConfig(BaseModel):
    inferenceSettings: Optional[Any] = None


class DebugInfo(BaseModel):
    autoGenerated: bool = True
    # This kind of config will
    # - could not disable quantization
    # - use modelbuilder for conversion
    # - output a model folder instead of model file
    useModelBuilder: Optional[str] = None
    # This kind of config will
    # - could not disable quantization
    # - use OpenVINOConversion for conversion
    useOpenVINOConversion: Optional[str] = None
    # This kind of config will
    # - could not disable quantization
    # - use OpenVINOConversion for conversion
    useOpenVINOOptimumConversion: Optional[str] = None

    def setupUseX(self, oliveJson: Any):
         # setup useModelBuilder
        modelBuilder = [k for k, v in oliveJson[OlivePropertyNames.Passes].items() if v[OlivePropertyNames.Type] == OlivePassNames.ModelBuilder]
        if modelBuilder:
            self.useModelBuilder = modelBuilder[0]

        # setup useOpenVINOConversion
        openVINOConversion = [k for k, v in oliveJson[OlivePropertyNames.Passes].items() if v[OlivePropertyNames.Type] == OlivePassNames.OpenVINOConversion]
        if openVINOConversion:
            self.useOpenVINOConversion = openVINOConversion[0]

        # setup useOpenVINOOptimumConversion
        openVINOOptimumConversion = [k for k, v in oliveJson[OlivePropertyNames.Passes].items() if v[OlivePropertyNames.Type] == OlivePassNames.OpenVINOOptimumConversion]
        if openVINOOptimumConversion:
            self.useOpenVINOOptimumConversion = openVINOOptimumConversion[0]

        if sum(bool(v) for v in [self.useModelBuilder, self.useOpenVINOConversion, self.useOpenVINOOptimumConversion]) > 1:
            printError(f"should not have both useModelBuilder and useOpenVINOConversion")
            return False
        return True

    def getUseX(self):
        if self.useModelBuilder:
            return self.useModelBuilder
        elif self.useOpenVINOConversion:
            return self.useOpenVINOConversion
        elif self.useOpenVINOOptimumConversion:
            return self.useOpenVINOOptimumConversion
        else:
            return None
        
    def isEmpty(self):
        return not (self.useModelBuilder or self.useOpenVINOConversion or self.useOpenVINOOptimumConversion)


class ModelParameter(BaseModelClass):
    name: str
    sections: List[Section]
    runtime: Parameter
    oliveFile: Optional[str] = None
    isLLM: Optional[bool] = None
    # For template using CUDA and no runtime overwrite, we need to set this so we know the target EP
    evalRuntime: Optional[RuntimeEnum] = None  # Changed to str to avoid forward reference
    debugInfo: Optional[DebugInfo] = None
    # A SHORTCUT FOR SEVERAL PARAMETERS
    # This kind of config will
    # - setup runtimeOverwrite for CUDA EP and others
    #   + the previous EP is used for EPContextBinaryGeneator by PythonEnvironment
    # - do not support cpu evaluation
    # - setup executeRuntimeFeatures, evalRuntimeFeatures
    isQNNLLM: Optional[bool] = None
    # SET AUTOMATICALLY
    isGPURequired: Optional[bool] = None
    runtimeOverwrite: Optional[RuntimeOverwrite] = None
    executeRuntimeFeatures: Optional[List[RuntimeFeatureEnum]] = None
    evalRuntimeFeatures: Optional[List[RuntimeFeatureEnum]] = None

    # it means default template does not use it
    # for Cpu, None means add
    addCpu: Optional[bool] = None
    addAmdNpu: Optional[ADMNPUConfig] = None

    @staticmethod
    def Read(parameterFile: str):
        printProcess(parameterFile)
        GlobalVars.configCheck += 1
        with open_ex(parameterFile, 'r') as file:
            parameterContent = file.read()
        modelParameter = ModelParameter.model_validate_json(parameterContent, strict=True)
        modelParameter._file = parameterFile
        modelParameter._fileContent = parameterContent
        return modelParameter

    def Check(self, templates: Dict[str, Parameter], oliveJson: Any, modelList: ModelList):
        if not self.sections:
            printError(f"{self._file} should have sections")
            return
        
        if not self.checkDebugInfo(oliveJson):
            return

        # TODO Add Convert section
        if self.sections[0].phase == PhaseTypeEnum.Conversion:
            self.sections = self.sections[1:]
        self.sections.insert(0, Section(
            autoGenerated=True,
            name="Convert",
            phase=PhaseTypeEnum.Conversion,
            parameters=[],
        ))
        
        if self.isQNNLLM:
            self.addCpu = False

        # Add runtime
        syskey, system = list(oliveJson[OlivePropertyNames.Systems].items())[0]
        currentEp = system[OlivePropertyNames.Accelerators][0][OlivePropertyNames.ExecutionProviders][0]
        runtimeValues: List[str] = [currentEp]
        runtimeDisplayNames = [GlobalVars.epToName[currentEp]]
        runtimeActions = None
        
        if self.addAmdNpu and currentEp != EPNames.VitisAIExecutionProvider.value:
            runtimeValues.append(EPNames.VitisAIExecutionProvider.value)
            runtimeDisplayNames.append(GlobalVars.epToName[EPNames.VitisAIExecutionProvider.value])
            evaluatorName = oliveJson[OlivePropertyNames.Evaluator]
            if evaluatorName and self.addAmdNpu.inferenceSettings:
                if runtimeActions is None:
                    runtimeActions = [[] for _ in range(len(runtimeValues))]
                else:
                    runtimeActions.append([])
                metricsNum = len(pydash.get(oliveJson, f"{OlivePropertyNames.Evaluators}.{evaluatorName}.{OlivePropertyNames.Metrics}"))
                for i in range(metricsNum):
                    runtimeActions[-1].append(ParameterAction(
                        path=f"{OlivePropertyNames.Evaluators}.{evaluatorName}.{OlivePropertyNames.Metrics}[{i}].{OlivePropertyNames.UserConfig}",
                        type=ParameterActionTypeEnum.Insert,
                        value={
                            "inference_settings": {
                                "onnx": self.addAmdNpu.inferenceSettings,
                            }
                        }
                    ))

        # CPU always last
        if self.addCpu != False and currentEp != EPNames.CPUExecutionProvider.value:
            runtimeValues.append(EPNames.CPUExecutionProvider.value)
            runtimeDisplayNames.append(GlobalVars.epToName[EPNames.CPUExecutionProvider.value])
            if runtimeActions is not None:
                runtimeActions.append([])
        
        self.runtime = Parameter(
            autoGenerated=True,
            name="Evaluate on",
            type=ParameterTypeEnum.Enum,
            values=runtimeValues,
            displayNames=runtimeDisplayNames,
            path=f"{OlivePropertyNames.Systems}.{syskey}.accelerators.0.execution_providers.0",
            readOnly=False,)
        self.runtime.actions = runtimeActions
        if not self.runtime.Check(False, oliveJson, modelList):
            printError(f"{self._file} runtime has error")

        # Add runtime overwrite
        if self.isQNNLLM:
            if not system[OlivePropertyNames.Type] == "PythonEnvironment":
                printError(f"{self._file}'s olive json does not use PythonEnvironment")
            self.runtimeOverwrite = RuntimeOverwrite(
                autoGenerated=True,
                pyEnvPath=f"{OlivePropertyNames.Systems}.{syskey}.{OlivePropertyNames.PythonEnvironmentPath}",
                executeEp=EPNames.CUDAExecutionProvider,
                evaluateUsedInExecute=True,)
            if not self.runtimeOverwrite.Check(oliveJson):
                printError(f"{self._file} runtime overwrite has error")
            # Import runtime features from somewhere
            from model_lab import RuntimeFeatureEnum
            self.executeRuntimeFeatures = [RuntimeFeatureEnum.AutoGptq]
            self.evalRuntimeFeatures = [RuntimeFeatureEnum.Nightly]

        for i, section in enumerate(self.sections):
            # Add conversion toggle
            if section.phase == PhaseTypeEnum.Conversion:
                conversion = None
                if self.debugInfo:
                    conversion = self.debugInfo.getUseX()
                if not conversion:
                    conversion = [k for k, v in oliveJson[OlivePropertyNames.Passes].items() if v[OlivePropertyNames.Type] == OlivePassNames.OnnxConversion][0]
                conversionPath = f"{OlivePropertyNames.Passes}.{conversion}"
                section.toggle = Parameter(
                    autoGenerated=True,
                    name="Convert to ONNX format",
                    type=ParameterTypeEnum.Bool,
                    path=conversionPath,
                    values=[],
                    actions=[[], []],
                    readOnly=True)

            # Add quantization toggle
            elif section.phase == PhaseTypeEnum.Quantization:
                toggleReadOnly = None
                actions = []
                quantize = None
                if self.debugInfo:
                    quantize = self.debugInfo.getUseX()
                if quantize:
                    toggleReadOnly = True
                else:
                    quantize = [k for k, v in oliveJson[OlivePropertyNames.Passes].items() if v[OlivePropertyNames.Type] in
                                [OlivePassNames.OnnxQuantization, OlivePassNames.OnnxStaticQuantization, OlivePassNames.OnnxDynamicQuantization]][0]
                    conversion = [(k, v) for k, v in oliveJson[OlivePropertyNames.Passes].items() if v[OlivePropertyNames.Type] == OlivePassNames.OnnxConversion][0]
                    actions = [ParameterAction(path=f"{OlivePropertyNames.Passes}", type=ParameterActionTypeEnum.Update, value={conversion[0]:conversion[1]})]
                quantizePath = f"{OlivePropertyNames.Passes}.{quantize}"
                section.toggle = Parameter(
                    autoGenerated=True,
                    name="Quantize model",
                    type=ParameterTypeEnum.Bool,
                    path=quantizePath,
                    values=[],
                    readOnly=toggleReadOnly,
                    actions=[[], actions])

            # Add evaluation toggle
            elif section.phase == PhaseTypeEnum.Evaluation:
                action = ParameterAction(path=OlivePropertyNames.Evaluator, type=ParameterActionTypeEnum.Delete)
                section.toggle = Parameter(
                    autoGenerated=True,
                    name="Evaluate model performance",
                    type=ParameterTypeEnum.Bool,
                    path=OlivePropertyNames.Evaluator,
                    values=[],
                    actions=[[], [action]])
                evaluatorName = oliveJson[OlivePropertyNames.Evaluator]
                if not checkPath(f"{OlivePropertyNames.Evaluators}.{evaluatorName}", oliveJson):
                    printError(f"{self._file} does not have evaluator {evaluatorName}")

            if not section.Check(templates, self._file or "", i, oliveJson, modelList):
                printError(f"{self._file} section {i} has error")

        if currentEp == EPNames.CUDAExecutionProvider.value or self.runtimeOverwrite and self.runtimeOverwrite.executeEp == EPNames.CUDAExecutionProvider:
            self.isGPURequired = True

        self.checkPhase(oliveJson)
        self.checkOliveFile(oliveJson)
        if self.debugInfo and self.debugInfo.isEmpty():
            self.debugInfo = None
        self.writeIfChanged()
    
    def checkPhase(self, oliveJson: Any):
        allPhases = [section.phase for section in self.sections]
        if len(allPhases) == 1 and allPhases[0] == PhaseTypeEnum.Conversion:
            pass
        elif len(allPhases) == 2 and allPhases[0] == PhaseTypeEnum.Conversion and allPhases[1] in [PhaseTypeEnum.Quantization, PhaseTypeEnum.Evaluation]:
            pass
        elif len(allPhases) == 3 and allPhases[0] == PhaseTypeEnum.Conversion and allPhases[1] == PhaseTypeEnum.Quantization and allPhases[2] == PhaseTypeEnum.Evaluation:
            pass
        else:
            printError(f"{self._file} has wrong phases {allPhases}")

        if PhaseTypeEnum.Evaluation in allPhases and PhaseTypeEnum.Quantization in allPhases and len(oliveJson[OlivePropertyNames.DataConfigs]) != 2:
            printWarning(f"{self._file}'s olive json should have two data configs for evaluation")

    def checkOliveFile(self, oliveJson: Any):
        if not GlobalVars.olivePath:
            return
        if not self.oliveFile:
            printWarning(f"{self._file} does not have oliveFile")
            return
        
        with open_ex(os.path.join(GlobalVars.olivePath, "examples", self.oliveFile), 'r') as file:
            oliveFileJson = json.load(file)
        diff = DeepDiff(oliveFileJson[OlivePropertyNames.Passes], oliveJson[OlivePropertyNames.Passes])
        
        addeds: list[str] = diff.pop('dictionary_item_added', [])
        newAddeds = []
        for added in addeds:
            if added.endswith("['save_as_external_data']"):
                # We add it to align model format
                pass
            else:
                newAddeds.append(added)
        if newAddeds:
            diff['dictionary_item_added'] = newAddeds

        removeds: list[str] = diff.pop('dictionary_item_removed', [])
        newRemoveds = []
        for removed in removeds:
            if removed.endswith("['reuse_cache']"):
                # In debug mode for olive, this will throw exception 'file is occupied' for ov recipes
                pass
            else:
                newRemoveds.append(removed)
        if newRemoveds:
            diff['dictionary_item_removed'] = newRemoveds

        changeds: dict[str, Any] = diff.pop('values_changed', {})
        newChangeds = {}
        for changed in changeds:
            if changed.endswith("['data_config']") or changed.endswith("['user_script']"):
                # Data config name or *.py could be different
                pass
            else:
                newChangeds[changed] = changeds[changed]
        if newChangeds:
            diff['values_changed'] = newChangeds

        if diff:
            # Check out branch hualxie/example_align for alignments
            printError(f"different from {self.oliveFile}\r\n{diff}")
        GlobalVars.oliveCheck += 1

    def checkDebugInfo(self, oliveJson: Any):
        self.debugInfo = DebugInfo()
        if not self.debugInfo.setupUseX(oliveJson):
            return False
        return True
