"""
Model parameter configuration classes
"""

from __future__ import annotations

import json
import os
import re
from typing import Any, Dict, Iterator, List, Optional

from deepdiff import DeepDiff
from model_lab import RuntimeEnum, RuntimeFeatureEnum
from pydantic import BaseModel

from .base import BaseModelClass
from .constants import (
    EPNames,
    OliveDeviceTypes,
    OlivePassNames,
    OlivePropertyNames,
    ParameterActionTypeEnum,
    ParameterTagEnum,
    ParameterTypeEnum,
    PhaseTypeEnum,
)
from .model_info import ModelList
from .parameters import Parameter, ParameterAction
from .utils import GlobalVars, checkPath, get_target_system, open_ex, printError, printProcess, printWarning


class RuntimeOverwrite(BaseModel):
    # This tag is only used for the case that when we edit the json, we know the property is auto generated by sanitize.py so no need to care about it
    autoGenerated: Optional[bool] = None
    pyEnvPath: Optional[str] = None
    executeEp: Optional[EPNames] = None
    # This is usually used for EP binary generation
    evaluateUsedInExecute: Optional[bool] = None

    def Check(self, oliveJson: Any):
        return self.pyEnvPath and checkPath(self.pyEnvPath, oliveJson)


class Section(BaseModel):
    # This tag is only used for the case that when we edit the json, we know the property is auto generated by sanitize.py so no need to care about it
    autoGenerated: Optional[bool] = None
    name: str
    phase: PhaseTypeEnum
    description: Optional[str] = None
    parameters: List[Parameter]
    disableToggleGeneration: Optional[bool] = None
    toggle: Optional[Parameter] = None

    @staticmethod
    def datasetPathPattern(path: str):
        return re.fullmatch(r"data_configs\[(0|[1-9]\d{0,2})\]\.load_dataset_config\.data_name", path)

    def Check(
        self,
        templates: Dict[str, Parameter],
        _file: str,
        sectionId: int,
        oliveJson: Any,
        modelList: ModelList,
    ):
        if not self.name:
            return False
        # if not self.description:
        #    return False
        # TODO add place holder for General?
        if not self.parameters and self.phase != PhaseTypeEnum.Conversion:
            printWarning(f"self.parameters is empty for {self.phase}.")

        for i, parameter in enumerate(self.parameters):
            if parameter.template:
                template = parameter.template
                if not isinstance(template, Parameter):
                    printError(f"{_file} section {sectionId} parameter {i} has wrong template")
                    continue
                if template.template not in templates:
                    printError(f"{_file} section {sectionId} parameter {i} has wrong template")
                    continue
                parameter.clearValue()
                parameter.applyTemplate(template)
                parameter.applyTemplate(templates[str(template.template)])
            if not parameter.Check(False, oliveJson, modelList):
                printError(f"{_file} section {sectionId} parameter {i} has error")

            # TODO move tag check into Parameter
            if parameter.path and Section.datasetPathPattern(parameter.path):
                if self.phase == PhaseTypeEnum.Quantization:
                    if not parameter.tags or ParameterTagEnum.QuantizationDataset not in parameter.tags:
                        printError(f"{_file} section {sectionId} parameter {i} should have QuantizationDataset tag")
                elif self.phase == PhaseTypeEnum.Evaluation:
                    if not parameter.tags or ParameterTagEnum.EvaluationDataset not in parameter.tags:
                        printError(f"{_file} section {sectionId} parameter {i} should have EvaluationDataset tag")
                if parameter.values:
                    missing_keys = [key for key in parameter.values if key not in modelList.HFDatasets]
                    if missing_keys:
                        printError(f"datasets are not in HFDatasets: {', '.join(str(key) for key in missing_keys)}")
            elif parameter.path and parameter.path.endswith("activation_type"):
                if not parameter.tags or ParameterTagEnum.ActivationType not in parameter.tags:
                    printError(f"{_file} section {sectionId} parameter {i} should have ActivationType tag")
            elif parameter.path and parameter.path.endswith("weight_type"):
                if not parameter.tags or ParameterTagEnum.WeightType not in parameter.tags:
                    printError(f"{_file} section {sectionId} parameter {i} should have WeightType tag")

        if self.toggle:
            if self.toggle.type != ParameterTypeEnum.Bool:
                printError(f"{_file} section {sectionId} toggle must use bool")
                return False
            if not self.toggle.Check(False, oliveJson, modelList):
                printError(f"{_file} section {sectionId} toggle has error")

        return True


class ADMNPUConfig(BaseModel):
    inferenceSettings: Optional[Any] = None


class DebugInfo(BaseModel):
    autoGenerated: bool = True
    # This kind of config will
    # - could not disable quantization
    # - use modelbuilder for conversion
    # - output a model folder instead of model file
    useModelBuilder: Optional[str] = None
    # This kind of config will
    # - could not disable quantization
    # - use OpenVINOConversion for conversion
    useOpenVINOConversion: Optional[str] = None
    # This kind of config will
    # - could not disable quantization
    # - use OpenVINOConversion for conversion
    useOpenVINOOptimumConversion: Optional[str] = None

    def setupUseX(self, oliveJson: Any):
        def getPass(passType: str):
            return next(
                (
                    k
                    for k, v in oliveJson[OlivePropertyNames.Passes].items()
                    if v[OlivePropertyNames.Type].lower() == passType
                ),
                None,
            )

        # setup useModelBuilder
        self.useModelBuilder = getPass(OlivePassNames.ModelBuilder)

        # setup useOpenVINOConversion
        self.useOpenVINOConversion = getPass(OlivePassNames.OpenVINOConversion)

        # setup useOpenVINOOptimumConversion
        self.useOpenVINOOptimumConversion = getPass(OlivePassNames.OpenVINOOptimumConversion)
        if (
            sum(
                bool(v)
                for v in [
                    self.useModelBuilder,
                    self.useOpenVINOConversion,
                    self.useOpenVINOOptimumConversion,
                ]
            )
            > 1
        ):
            printError(f"should not have both useModelBuilder and useOpenVINOConversion")
            return False
        return True

    def getUseX(self):
        if self.useModelBuilder:
            return self.useModelBuilder
        elif self.useOpenVINOConversion:
            return self.useOpenVINOConversion
        elif self.useOpenVINOOptimumConversion:
            return self.useOpenVINOOptimumConversion
        else:
            return None

    def isEmpty(self):
        return not (self.useModelBuilder or self.useOpenVINOConversion or self.useOpenVINOOptimumConversion)


class ModelParameter(BaseModelClass):
    name: str
    oliveFile: Optional[str] = None
    isLLM: Optional[bool] = None
    isIntel: Optional[bool] = None
    intelRuntimeValues: Optional[List[OliveDeviceTypes]] = None
    # For template using CUDA and no runtime overwrite, we need to set this so we know the target EP
    evalRuntime: Optional[RuntimeEnum] = None  # Changed to str to avoid forward reference
    debugInfo: Optional[DebugInfo] = None
    # A SHORTCUT FOR SEVERAL PARAMETERS
    # This kind of config will
    # - setup runtimeOverwrite for CUDA EP and others
    #   + the previous EP is used for EPContextBinaryGeneator by PythonEnvironment
    # - do not support cpu evaluation
    # - setup executeRuntimeFeatures, pyEnvRuntimeFeatures
    isQNNLLM: Optional[bool] = None
    # SET AUTOMATICALLY
    isGPURequired: Optional[bool] = None
    runtimeOverwrite: Optional[RuntimeOverwrite] = None
    executeRuntimeFeatures: Optional[List[RuntimeFeatureEnum]] = None
    evaluationRuntimeFeatures: Optional[List[RuntimeFeatureEnum]] = None
    pyEnvRuntimeFeatures: Optional[List[RuntimeFeatureEnum]] = None
    # it means default template does not use it
    # for Cpu, None means add
    addCpu: Optional[bool] = None
    addAmdNpu: Optional[ADMNPUConfig] = None

    runtime: Parameter
    runtimeInConversion: Optional[Parameter] = None
    sections: List[Section]

    @staticmethod
    def Read(parameterFile: str):
        printProcess(parameterFile)
        with open_ex(parameterFile, "r") as file:
            parameterContent = file.read()
        modelParameter = ModelParameter.model_validate_json(parameterContent, strict=True)
        modelParameter._file = parameterFile
        modelParameter._fileContent = parameterContent
        return modelParameter

    def getIntelDevices(self) -> Iterator[OliveDeviceTypes]:
        for tmpDevice in OliveDeviceTypes:
            if tmpDevice == OliveDeviceTypes.Any:
                continue
            if self.intelRuntimeValues and tmpDevice not in self.intelRuntimeValues:
                continue
            yield tmpDevice

    def Check(self, templates: Dict[str, Parameter], oliveJson: Any, modelList: ModelList):
        GlobalVars.configCheck.append(self._file)

        if not self.sections:
            printError(f"{self._file} should have sections")
            return

        if not self.checkDebugInfo(oliveJson):
            return

        if self.sections[0].phase == PhaseTypeEnum.Conversion:
            self.sections = self.sections[1:]
        self.sections.insert(
            0,
            Section(
                autoGenerated=True,
                name="Convert",
                phase=PhaseTypeEnum.Conversion,
                parameters=[],
            ),
        )

        if self.isQNNLLM:
            self.addCpu = False

        # Add runtime
        syskey, system = get_target_system(oliveJson)
        currentEp = system[OlivePropertyNames.Accelerators][0][OlivePropertyNames.ExecutionProviders][0]
        currentOliveDeviceType = system[OlivePropertyNames.Accelerators][0].get(
            OlivePropertyNames.Device, OliveDeviceTypes.Any.value
        )
        currentRuntimeRPC = GlobalVars.GetRuntimeRPC(currentEp, currentOliveDeviceType)
        # use any for default
        if currentEp == EPNames.OpenVINOExecutionProvider.value:
            currentRuntimeRPC = RuntimeEnum.IntelAny

        runtimeValues: List[str] = [currentEp]
        runtimeDisplayNames = [GlobalVars.RuntimeToDisplayName[currentRuntimeRPC]]

        runtimeActions = None

        # CPU always last
        if self.addCpu != False and currentRuntimeRPC != RuntimeEnum.CPU:
            runtimeValues.append(GlobalVars.RuntimeToEPName[RuntimeEnum.CPU].value)
            runtimeDisplayNames.append(GlobalVars.RuntimeToDisplayName[RuntimeEnum.CPU])
            if runtimeActions is not None:
                runtimeActions.append([])

        self.runtime = Parameter(
            autoGenerated=True,
            name="Evaluate on",
            type=ParameterTypeEnum.Enum,
            values=runtimeValues,
            displayNames=runtimeDisplayNames,
            path=f"{OlivePropertyNames.Systems}.{syskey}.{OlivePropertyNames.Accelerators}.0.{OlivePropertyNames.ExecutionProviders}.0",
            readOnly=False,
        )
        if currentEp == EPNames.OpenVINOExecutionProvider.value:
            self.runtime.path = (
                f"{OlivePropertyNames.Systems}.{syskey}.{OlivePropertyNames.Accelerators}.0.{OlivePropertyNames.Device}"
            )
            self.runtime.values = []
            self.runtime.displayNames = []
            for tmpDevice in self.getIntelDevices():
                tmpRuntimeRPC = GlobalVars.GetRuntimeRPC(EPNames.OpenVINOExecutionProvider, tmpDevice)
                self.runtime.values.append(GlobalVars.RuntimeToOliveDeviceType[tmpRuntimeRPC].value)
                self.runtime.displayNames.append(GlobalVars.RuntimeToDisplayName[tmpRuntimeRPC])

        self.runtime.actions = runtimeActions
        self.TryToRemoveReuseCacheInRuntimeAction(oliveJson)
        if not self.runtime.Check(False, oliveJson, modelList):
            printError(f"{self._file} runtime has error")

        # Add runtime overwrite
        if self.isQNNLLM:
            if not system[OlivePropertyNames.Type] == "PythonEnvironment":
                printError(f"{self._file}'s olive json does not use PythonEnvironment")
            self.runtimeOverwrite = RuntimeOverwrite(
                autoGenerated=True,
                pyEnvPath=f"{OlivePropertyNames.Systems}.{syskey}.{OlivePropertyNames.PythonEnvironmentPath}",
                executeEp=EPNames.CUDAExecutionProvider,
                evaluateUsedInExecute=True,
            )
            if self.runtimeOverwrite and not self.runtimeOverwrite.Check(oliveJson):
                printError(f"{self._file} runtime overwrite has error")
            self.executeRuntimeFeatures = [RuntimeFeatureEnum.AutoGptq]
            self.pyEnvRuntimeFeatures = [RuntimeFeatureEnum.Nightly]

        for tmpDevice, section in enumerate(self.sections):
            # Add conversion toggle
            if section.phase == PhaseTypeEnum.Conversion:
                if not section.disableToggleGeneration:
                    conversion = None
                    if self.debugInfo:
                        conversion = self.debugInfo.getUseX()
                    if not conversion:
                        conversion = [
                            k
                            for k, v in oliveJson[OlivePropertyNames.Passes].items()
                            if v[OlivePropertyNames.Type].lower() == OlivePassNames.OnnxConversion
                        ][0]
                    conversionPath = f"{OlivePropertyNames.Passes}.{conversion}"
                    section.toggle = Parameter(
                        autoGenerated=True,
                        name="Convert to ONNX format",
                        type=ParameterTypeEnum.Bool,
                        path=conversionPath,
                        actions=[[], []],
                        readOnly=True,
                    )

            # Add quantization toggle
            elif section.phase == PhaseTypeEnum.Quantization:
                if not section.disableToggleGeneration:
                    toggleReadOnly = None
                    actions = []
                    quantize = None
                    if self.debugInfo:
                        quantize = self.debugInfo.getUseX()
                    if quantize:
                        toggleReadOnly = True
                    else:
                        quantize = [
                            k
                            for k, v in oliveJson[OlivePropertyNames.Passes].items()
                            if v[OlivePropertyNames.Type].lower()
                            in [
                                OlivePassNames.OnnxQuantization,
                                OlivePassNames.OnnxStaticQuantization,
                                OlivePassNames.OnnxDynamicQuantization,
                            ]
                        ][0]
                        conversion = [
                            (k, v)
                            for k, v in oliveJson[OlivePropertyNames.Passes].items()
                            if v[OlivePropertyNames.Type].lower() == OlivePassNames.OnnxConversion
                        ][0]
                        actions = [
                            ParameterAction(
                                path=f"{OlivePropertyNames.Passes}",
                                type=ParameterActionTypeEnum.Update,
                                value={conversion[0]: conversion[1]},
                            )
                        ]
                    quantizePath = f"{OlivePropertyNames.Passes}.{quantize}"
                    section.toggle = Parameter(
                        autoGenerated=True,
                        name="Quantize model",
                        type=ParameterTypeEnum.Bool,
                        path=quantizePath,
                        readOnly=toggleReadOnly,
                        actions=[[], actions],
                    )

            # Add evaluation toggle
            elif section.phase == PhaseTypeEnum.Evaluation:
                if not section.disableToggleGeneration:
                    action = ParameterAction(
                        path=OlivePropertyNames.Evaluator,
                        type=ParameterActionTypeEnum.Delete,
                    )
                    section.toggle = Parameter(
                        autoGenerated=True,
                        name="Evaluate model performance",
                        type=ParameterTypeEnum.Bool,
                        path=OlivePropertyNames.Evaluator,
                        actions=[[], [action]],
                    )
                evaluatorName = oliveJson[OlivePropertyNames.Evaluator]
                if not checkPath(f"{OlivePropertyNames.Evaluators}.{evaluatorName}", oliveJson):
                    printError(f"{self._file} does not have evaluator {evaluatorName}")

            if not section.Check(templates, self._file or "", tmpDevice, oliveJson, modelList):
                printError(f"{self._file} section {tmpDevice} has error")

        if (
            currentEp == EPNames.CUDAExecutionProvider.value
            or self.runtimeOverwrite
            and self.runtimeOverwrite.executeEp == EPNames.CUDAExecutionProvider
        ):
            self.isGPURequired = True

        self.checkPhase(oliveJson)
        self.CheckRuntimeInConversion(oliveJson, modelList)
        self.checkOliveFile(oliveJson)
        if self.debugInfo and self.debugInfo.isEmpty():
            self.debugInfo = None
        self.writeIfChanged()

    def TryToRemoveReuseCacheInRuntimeAction(self, oliveJson: Any):
        if not self.runtime.values:
            printError(f"{self._file} runtime values is empty, cannot remove reuse_cache")
            return
        # Find all passes that have reuse_cache field
        reuse_cache_paths = []
        if OlivePropertyNames.Passes in oliveJson:
            for pass_key, pass_value in oliveJson[OlivePropertyNames.Passes].items():
                if "reuse_cache" in pass_value:
                    reuse_cache_path = f"{OlivePropertyNames.Passes}.{pass_key}.reuse_cache"
                    reuse_cache_paths.append(reuse_cache_path)

        if reuse_cache_paths:
            if self.runtime.actions is None:
                self.runtime.actions = []
            for i in range(len(self.runtime.values)):
                if i >= len(self.runtime.actions):
                    self.runtime.actions.append([])
                for tmpPath in reuse_cache_paths:
                    self.runtime.actions[i].append(
                        ParameterAction(
                            path=tmpPath,
                            type=ParameterActionTypeEnum.Delete,
                        )
                    )
        return None

    def CheckRuntimeInConversion(self, oliveJson: Any, modelList: ModelList):
        def getOpenVINOPass(passType: str):
            return next(
                (
                    (k, v)
                    for k, v in oliveJson[OlivePropertyNames.Passes].items()
                    if v[OlivePropertyNames.Type].lower() == passType
                ),
                None,
            )

        openVINOOptimumConversion = getOpenVINOPass(OlivePassNames.OpenVINOOptimumConversion)
        openVINOQuantization = getOpenVINOPass(OlivePassNames.OpenVINOQuantization)
        openVINOEncapsulation = getOpenVINOPass(OlivePassNames.OpenVINOEncapsulation)

        def addRuntimeInConversion(runtime: Parameter, path: str, values: List[Any]):
            if not runtime.path:
                runtime.path = path
                runtime.values = values
                runtime.displayNames = [
                    GlobalVars.RuntimeToDisplayName[GlobalVars.GetRuntimeRPC(EPNames.OpenVINOExecutionProvider, e)]
                    for e in values
                ]
            else:
                if runtime.actions is None:
                    runtime.actions = []
                for i in range(len(values)):
                    if i >= len(runtime.actions):
                        runtime.actions.append([])
                    runtime.actions[i].append(
                        ParameterAction(
                            path=path,
                            type=ParameterActionTypeEnum.Update,
                            value=values[i],
                        )
                    )

        if openVINOOptimumConversion or openVINOQuantization or openVINOEncapsulation:
            self.runtimeInConversion = Parameter(
                autoGenerated=True, name="Convert/Quantize to", type=ParameterTypeEnum.Enum
            )
            if openVINOOptimumConversion:
                addRuntimeInConversion(
                    self.runtimeInConversion,
                    f"{OlivePropertyNames.Passes}.{openVINOOptimumConversion[0]}.{OlivePropertyNames.ExtraArgs}.{OlivePropertyNames.Device}",
                    # TODO support any after olive release
                    [e.value for e in self.getIntelDevices()],
                )
            if openVINOQuantization:
                addRuntimeInConversion(
                    self.runtimeInConversion,
                    f"{OlivePropertyNames.Passes}.{openVINOQuantization[0]}.{OlivePropertyNames.TargetDevice}",
                    # TODO support any after olive release
                    [e.value for e in self.getIntelDevices()],
                )
            if openVINOEncapsulation:
                addRuntimeInConversion(
                    self.runtimeInConversion,
                    f"{OlivePropertyNames.Passes}.{openVINOEncapsulation[0]}.{OlivePropertyNames.TargetDevice}",
                    # TODO support any after olive release
                    [e.value for e in self.getIntelDevices()],
                )
            if not self.runtimeInConversion.Check(False, oliveJson, modelList):
                printError(f"{self._file} runtime in conversion has error")

    def checkPhase(self, oliveJson: Any):
        allPhases = [section.phase for section in self.sections]
        if len(allPhases) == 1 and allPhases[0] == PhaseTypeEnum.Conversion:
            pass
        elif (
            len(allPhases) == 2
            and allPhases[0] == PhaseTypeEnum.Conversion
            and allPhases[1] in [PhaseTypeEnum.Quantization, PhaseTypeEnum.Evaluation]
        ):
            pass
        elif (
            len(allPhases) == 3
            and allPhases[0] == PhaseTypeEnum.Conversion
            and allPhases[1] == PhaseTypeEnum.Quantization
            and allPhases[2] == PhaseTypeEnum.Evaluation
        ):
            pass
        else:
            printError(f"{self._file} has wrong phases {allPhases}")

        if (
            PhaseTypeEnum.Evaluation in allPhases
            and PhaseTypeEnum.Quantization in allPhases
            and len(oliveJson[OlivePropertyNames.DataConfigs]) != 2
        ):
            printWarning(f"{self._file}'s olive json should have two data configs for evaluation")

    def checkOliveFile(self, oliveJson: Any):
        if not GlobalVars.olivePath:
            return
        if not self.oliveFile:
            printWarning(f"{self._file} does not have oliveFile")
            return

        with open_ex(os.path.join(GlobalVars.olivePath, "examples", self.oliveFile), "r") as file:
            oliveFileJson = json.load(file)

        diff = DeepDiff(
            oliveFileJson[OlivePropertyNames.Passes],
            oliveJson[OlivePropertyNames.Passes],
        )

        addeds: list[str] = diff.pop("dictionary_item_added", [])
        newAddeds = []
        for added in addeds:
            if added.endswith("['save_as_external_data']"):
                # We add it to align model format
                pass
            else:
                newAddeds.append(added)
        if newAddeds:
            diff["dictionary_item_added"] = newAddeds

        removeds: list[str] = diff.pop("dictionary_item_removed", [])
        newRemoveds = []
        for removed in removeds:
            if removed.endswith("['reuse_cache']"):
                # In debug mode for olive, this will throw exception 'file is occupied' for ov recipes
                pass
            else:
                newRemoveds.append(removed)
        if newRemoveds:
            diff["dictionary_item_removed"] = newRemoveds

        changeds: dict[str, Any] = diff.pop("values_changed", {})
        newChangeds = {}
        for changed in changeds:
            if changed.endswith("['data_config']") or changed.endswith("['user_script']"):
                # Data config name or *.py could be different
                pass
            else:
                newChangeds[changed] = changeds[changed]
        if newChangeds:
            diff["values_changed"] = newChangeds

        if diff:
            # Check out branch hualxie/example_align for alignments
            printError(f"different from {self.oliveFile}\r\n{diff}")
        GlobalVars.oliveCheck += 1

    def checkDebugInfo(self, oliveJson: Any):
        self.debugInfo = DebugInfo()
        if not self.debugInfo.setupUseX(oliveJson):
            return False
        return True
